<div ref:box class="slider alpha-check-bg {{direction}}">
  <canvas ref:slider class="slider-canvas" width={{rect.width}} height={{rect.height}}></canvas>
  <div ref:sliderHandle class="slider-handle {{direction}}"></div>
</div>

<style>
  .slider {
    position: relative;
  }
  .slider.vertical {
    cursor: row-resize;
    height: 100%;
  }
  .slider.horizontal {
    cursor: col-resize;
    width: 100%;
  }

  .slider-canvas {
    margin: 0;
    padding: 0;
  }
  .slider-handle {
    position: absolute;
    top: 0;
    left: 0;
    border: 1px solid black;
    pointer-events: none;
  }
  .slider-handle.vertical {
    margin-top: -3px;
    width: 100%;
    height: 6px;
  }
  .slider-handle.horizontal {
    margin-left: -3px;
    width: 6px;
    height: 100%;
  }
  .slider-handle::before {
    content: '';
    position: absolute;
    width: 100%;
    height: 100%;
    top: 0;
    left: 0;
    border: 1px solid white;
  }
</style>

<script>
  import { MousePosition } from '../mouse.js'
  export default {
    data () {
      return {
        size: 0,
        rect: {width: 0, height: 0, left: 0, top: 0},
        strokeWidth: 20,
        direction: 'vertical',
        value: 50,
        min: 0,
        max: 100,
        step: 1,
        reverse: false
      }
    },
    computed: {
      width: (direction, size, strokeWidth) => direction === 'vertical' ? strokeWidth : size,
      height: (direction, size, strokeWidth) => direction === 'vertical' ? size : strokeWidth,
    },
    oncreate () {
      // get size getBoundingClientRect() / getClientRect()[0]
      // const rect = this.refs.box.getBoundingClientRect()
      const rect = {
        width: this.refs.box.clientWidth,
        height: this.refs.box.clientHeight,
      }
      console.log('rect', rect)
      this.set({rect})
      if (rect.width > rect.height) {
        this.set({
          direction: 'horizontal'
        })
      }
      this.set({
        size: Math.max(rect.width, rect.height)
      })

      this.draw('hue')

      this.observe('value', (value) => {
        this.fire('change')
        this.setPosition(value)
      })
      // picker
      new MousePosition(this.refs.slider, { // eslint-disable-line no-new
        // handle: this.refs.sliderHandle,
        start: (e, position) => {
          this.setValue(position)
        },
        drag: (e, position) => {
          this.setValue(position)
        },
      })
    },
    methods: {
      setValue (position) {
        const max = this.get('max')
        const min = this.get('min')
        const side = this.get('direction') === 'vertical' ? 'percentTop' : 'percentLeft'
        let per = position[side] / 100
        if (this.get('reverse')) {
          per = 1 - per
        }
        this.set({
          value: (max - min) * per + min
        })
      },
      setPosition (value) {
        const size = this.get('size')
        const max = this.get('max')
        const min = this.get('min')
        const side = this.get('direction') === 'vertical' ? 'top' : 'left'
        let per = value / (max - min)
        if (this.get('reverse')) {
          per = 1 - per
        }
        this.refs.sliderHandle.style[side] = per * (size - 6) + 3 + 'px'
      },
      draw (beginColor, endColor) {
        const cxt = this.refs.slider.getContext('2d')
        const size = this.get('size')
        cxt.clearRect(0, 0, size, size)

        const grd = this.get('direction') === 'vertical'
          ? cxt.createLinearGradient(0, 0, 0, size)
          : cxt.createLinearGradient(0, 0, size, 0)

        const [begin, end] = this.get('reverse') ? [1, 0] : [0, 1]

        if (beginColor === 'hue') {
          // hue gradient bar
          const len = 12
          for (let i = 0; i <= len; i++) {
            grd.addColorStop(1 / len * i, `hsl(${360 / len * i}, 100%, 50%)`)
          }
        } else {
          grd.addColorStop(begin, beginColor + '')
          grd.addColorStop(end, endColor + '')
        }

        cxt.fillStyle = grd
        cxt.fillRect(0, 0, size, size)
      }
    }
  }
</script>
