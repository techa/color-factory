<div class="blender">
  <dv ref:color1 on:click="set({color1: color})" class="blender-btn color1"></dv>
  <div ref:blender class="blender-slider">
    <canvas ref:canvas class="blender-canvas" {...rect} ></canvas>
    <div ref:handle class="blender-handle {direction}"></div>
  </div>
  <dv ref:color2 on:click="set({color2: color})" class="blender-btn color2"></dv>
</div>

<style>
  .blender {
    height: 100%;
    display: flex;
    align-items: stretch;
    flex-direction: row;
    justify-content: space-around;
  }
  .blender-slider {
    position: relative;
    height: inherit;
    flex: 2 1 auto;
    margin: 0 2px;
    background-color: #fff;
    background-image: linear-gradient(45deg, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%, #ddd),
                      linear-gradient(45deg, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%, #ddd);
    background-size: 8px 8px;
    background-position:0 0, 4px 4px;
    background-repeat: repeat;
  }
  .blender-canvas {
    vertical-align: baseline;
  }
  .blender-btn {
    display: block;
    width: inherit;
    height: inherit;
    flex: 0 1 20px;
    border: 1px solid #888888;
  }
  .blender-handle {
    position: absolute;
    margin-left: -.5px;
    width: 1px;
    height: inherit;
    top: 0;
    left: 0;
    pointer-events: none;
  }
  .blender-handle.vertical {
    margin-top: -.5px;
    width: inherit;
    height: 1px;
  }
  .blender-handle.horizontal {
    margin-left: -.5px;
    width: 1px;
    height: inherit;
  }
</style>

<script>
  import Color from '../Colorx.js'
  import { MousePosition } from '../mouse.js'
  export default {
    data () {
      return {
        rect: { width: 0, height: 0 },
        color1: '#000',
        color2: '#fff',
      }
    },
    oncreate () {
      const rect = {
        width: this.refs.blender.clientWidth,
        height: this.refs.blender.clientHeight,
      }
      this.set({ rect })
      // picker
      new MousePosition(this.refs.blender, { // eslint-disable-line no-new
        handle: this.refs.handle,
        start: (e, position) => {
          this.set({ color: this.getColor(position) })
        },
        drag: (e, position) => {
          this.set({ color: this.getColor(position) })
        },
      })
    },
    onupdate ({ changed, current }) {
      if (changed.color1) {
        this.refs.color1.style.backgroundColor = current.color1.toString()
        this.draw()
      }
      if (changed.color2) {
        this.refs.color2.style.backgroundColor = current.color2.toString()
        this.draw()
      }
    },
    methods: {
      getColor (position) {
        const { width } = this.get().rect
        const x = Math.max(0, Math.min(position.x, width - 1))
        const [r, g, b] = this.refs.canvas.getContext('2d').getImageData(x, 0, 1, 1).data
        const color = new Color({ r, g, b })

        this.refs.handle.style.left = x + 'px'
        this.refs.handle.style.backgroundColor = color.isDark() ? '#fff' : '#000'
        return color
      },
      draw () {
        const { direction, color1, color2 } = this.get()
        const canvas = this.refs.canvas
        const cxt = canvas.getContext('2d')
        const [w, h] = [canvas.width, canvas.height]
        cxt.clearRect(0, 0, w, h)

        const grd = direction === 'vertical'
          ? cxt.createLinearGradient(0, 0, 0, h)
          : cxt.createLinearGradient(0, 0, w, 0)

        grd.addColorStop(0.02, new Color(color1).rgb().string())
        grd.addColorStop(0.98, new Color(color2).rgb().string())

        cxt.fillStyle = grd
        cxt.fillRect(0, 0, w, h)

        this.getColor({ x: w / 2 })
      }
    }
  }
</script>
