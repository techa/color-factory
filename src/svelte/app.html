<div id="controller" style="color: {textColor};">
  <div class="tool-box">
    <button on:click="set({ showModal: true })" title="Save">
      <i class="fas fa-hdd"></i>
    </button>
    <button on:click="$undo()" title="Undo: ctrl+z">
      <i class="fas fa-undo"></i>
      <!-- ↩️ -->
    </button>
    <button on:click="$redo()" title="Redo: ctrl+shift+z">
      <i class="fas fa-redo"></i>
      <!-- ↪️ -->
    </button>
    <button on:click="$set({grayscale: !$grayscale}, true)" title="Filter grayscale">
      <i class="fas fa-eye-dropper"></i>
    </button>
    <button on:click="$set({textvisible: !$textvisible}, true)" title="Card Text Visible">
      <i class="fas fa-font"></i>
    </button>
    <button on:click="removeAll()" title="Delete">
      <i class="fas fa-trash"></i>
    </button>
  </div>

  <!-- カード整列 -->
  <div class="button-set border radius">
    <div><button on:click="cardsPosition('sortX')">X</button></div>
    <ladel class="select-wrapper" style="flex: 1 1 auto;">
      <select bind:value="$sortX" on:change="cardsPosition('sortX', this.value)">
        {#each sort as key}
        <option value="{key.value}">{key.name}</option>
        {/each}
      </select>
    </ladel>

    <div><button on:click="cardsPosition('sortY')">Y</button></div>
    <ladel class="select-wrapper" style="flex: 1 1 auto;">
      <select bind:value="$sortY" on:change="cardsPosition('sortY', this.value)">
        {#each sort as key}
        <option value="{key.value}">{key.name}</option>
        {/each}
      </select>
    </ladel>
  </div>

  <hr>

  <div class="top-input-wrapper button-set border radius">
    <div>
      <input ref:name bind:value="current.name" placeholder="{current.color.nearColorName()}" style="color: {textColor};">
    </div>
    <div>
      <button
        on:click="addCard(current, true)"
        title="Add Card: text"
        style="color: {current.color};">➕</button>
    </div>
    <div>
      <button
        on:click="addCard(current)"
        title="Add Card: fill"
        style="color:{current.color.isDark()?'#fff':'#000'};background-color: {current.color};">➕</button>
    </div>
    <div><button on:click="setBgColor(current.color)" title="set Background Color">BG</button></div>
  </div>

  <ColorPicker bind:color="current.color" bgColor="{$bgColor}" on:setBgColor="setBgColor(current.color)" />
  <hr>
  <ColorLists on:colorpick="set({current: event.current})" />
</div>

<div ref:box id="box" style="background-color: {bgColor};">
  {#each $cards as card, index}
    <ColorCard {card} {index} />
  {/each}
</div>

<div class="links" style="color: {textColor};">
  <a href="https://github.com/techa/color-factory"><i class="fab fa-github fa-fw"></i></a>
</div>

<ContextMenu />

{#if showModal}
<SaveModal on:close='set({ showModal: false })'></SaveModal>
{/if}

<script>
  import ColorPicker from '../color-picker/color-picker.html'

  import ColorCard from './color-card.html'
  import ColorLists from './color-lists.html'
  import ContextMenu from './context-menu.html'

  import SaveModal from './save-modal.html'

  import Color from 'color'
  import store from '../store/store.js'
  import {Selectable} from '../mouse'

  const sort = [
    {name: '---', value: 'none'},
    {name: 'Random', value: 'random'},
    {name: 'Hue', value: 'hue'},
    {name: 'Hue(∠)', value: 'deg'},
    {name: 'S(HSL)', value: 'saturationl'},
    {name: 'L(HSL)', value: 'lightness'},
    {name: 'S(HSV)', value: 'saturationv'},
    {name: 'V(HSV)', value: 'value'},
    {name: 'C(HCG)', value: 'chroma'},
    {name: 'G(HCG)', value: 'gray'},
    {name: 'W(HWB)', value: 'white'},
    {name: 'B(HWB)', value: 'wblack'},
    {name: 'C(CMYK)', value: 'cyan'},
    {name: 'M(CMYK)', value: 'magenta'},
    {name: 'Y(CMYK)', value: 'yellow'},
    {name: 'B(CMYK)', value: 'black'},
    {name: 'Contrast', value: 'contrast'},
  ]

  export default {
    components: {
      ColorPicker,
      ColorCard,
      ColorLists,
      ContextMenu,
      SaveModal,
    },
    store: () => store,
    data () {
      return {
        current: {
          name: '',
          color: Color.random(),
        },
        memo: null,
        selectingCard: null,
        sort,
      }
    },
    computed: {
      textColor: ({ $bgColor }) => Color($bgColor).isDark() ? '#fff' : '#000',
      bgColor: ({ $bgColor, $grayscale }) => $grayscale ? Color($bgColor).grayscale() : Color($bgColor),
    },
    oncreate () {
      this.refs.name.addEventListener('focus', function (e) {
        if (!this.value) {
          this.value = this.placeholder
          this.selectionStart = 0
          this.selectionEnd = this.placeholder.length
        }
      })
      const box = this.refs.box
      const cardSize = 120
      const colorsWidth = 320
      const byer = (sort, card, dirctionflg) => {
        let by
        switch (sort) {
          case null:
          case undefined:
          case 'none':
          case 'random':
            return Math.random()
          case 'deg':
            return (card.color.hue() - 90) * Math.PI / 180
          case 'contrast':
            by = (this.store.get().bgColor[sort](card.color) - 1) / 20
            break
          default:
            const max = sort === 'hue' ? 360 : 100
            by = card.color[sort]() / max
            break
        }
        return dirctionflg ? by : 1 - by
      }
      // card position init
      store.cardPosition = (card) => {
        const rect = box.getBoundingClientRect()
        const {sortX, sortY} = this.store.get()
        const maxW = rect.width - cardSize - colorsWidth
        const maxH = rect.height - cardSize

        if (sortX === 'deg' || sortY === 'deg') {
          // Circle
          const deg = sortX === 'deg' ? byer(sortX, card) : byer(sortY, card)
          const radius = sortY === 'deg' ? byer(sortX, card, true) : byer(sortY, card, true)
          const maxR = Math.min(maxW, maxH) / 2
          console.log('deg', card.color.hsl(),  deg)
          card.left = maxR * Math.cos(deg) * radius + maxR + colorsWidth
          card.top = maxR * Math.sin(deg) * radius + maxR + cardSize / 2
        } else {
          if (card.left == null || sortX !== 'none') {
            card.left = Math.round((maxW) * byer(sortX, card) + colorsWidth)
          }
          if (card.top == null || sortY !== 'none') {
            card.top = Math.round((maxH) * byer(sortY, card))
          }
        }
        return card
      }
      // Selectable
      this.selectable = new Selectable(this.refs.box, {
        filter: '.card',
        start: (e, position) => {
          this.store.fire('menu_close')
        },
        selected: (e) => {
          const selects = this.selectable.selects
          const {memo, current} = this.get()

          if (selects.length === 1) {
            const {name, color} = store.get().cards[selects[0].index]
            this.set({current: { name, color }})
            if (!memo) {
              this.set({ memo: current })
            }
          }

          if (!selects.length && memo) {
            this.set({current: memo, memo: null})
          }
        },
      })

      this.store.on('selectAll', () => {
        this.selectable.selectAll()
      })
      this.cardsPosition()
    },

    methods: {
      addCard (current, textMode) {
        const {name, color} = current
        if (!name) {
          current.name = color.nearColorName()
        }
        this.store.fire('cards.ADD_CARD', Object.assign({textMode}, current))
        this.set({current: { name: '', color }})
      },
      cardsPosition (sortXY, value) {
        if (sortXY && value) {
          this.store.set({[sortXY]: value})
        }
        const {cards} = this.store.get()
        cards.forEach((card, i) => {
          cards[i] = this.store.cardPosition(card)
        })
        this.store.set({cards})
        this.store.memo()
      },
      setBgColor (color) {
        const {bgColor} = this.store.get()
        const coloraplha1 = bgColor.alphaBlending(color)
        this.store.set({bgColor: coloraplha1})
        this.addCard({name: 'background', color: coloraplha1})
      },
      removeAll () {
        const selects = this.selectable.selects
        if (selects.length) {
          store.fire('cards.REMOVE_CARD', selects.map((select) => select.index))
        } else {
          this.store.set({cards: []})
          this.store.memo()
        }
      },
    }
  }
</script>

<style>
  option {
    color: #111;
  }
  #controller {
    width: 320px;
    height: 100vh;
    position: absolute;
    margin:0;
    padding: 10px 20px;
    top:0;
    left:0;
  }
  #box {
    width: 100%;
    height: 100%;
  }
  .tool-box {
    padding-bottom: 10px;
  }
  .top-input-wrapper {
    width: 100%;
  }
  .top-input-wrapper > div {
    height: 2em;
  }
  .top-input-wrapper > div > * {
    height: 100%;
    width: 100%;
  }
  .top-input-wrapper input {
    padding: 0 8px;
  }
  .links {
    position: absolute;
    top: 4px;
    right: 4px;
    z-index: 5000;
  }
  .links a,.links a:visited,.links a:active  {
    color: inherit;
  }
</style>
