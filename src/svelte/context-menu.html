<div ref:menu id="menu">
  {#if mode == 'tip'}
    <p class="menuitem" on:click="add()">ADD CARD</p>
  {:elseif mode == 'card'}
    <p class="menuitem" on:click="edit()">
      <i class="fas fa-edit fa-fw"></i>
      EDIT
    </p>
    <p class="menuitem" on:click="duplicate()">
      <i class="fas fa-copy fa-fw"></i>
      DUPLICATE
    </p>
    <p class="menuitem" on:click="reverse()">
      <i class="fas fa-sync fa-fw"></i>
      REVERSE
    </p>
    <p class="menuitem" on:click="remove()">
      <i class="fas fa-times fa-fw"></i>
      DELETE
    </p>
    <hr>
    <!-- <p class="menuitem" on:mouseover="submenuVisible(this)">
      <i class="fas fa-eye fa-fw"></i>
      VIEW
      <span>▶</span>
    </p> -->
  {/if}
  <hr>
  {#if activeCard}
    {#each copys as model}
      <p class="menuitem" on:click="copyColor(model)">
        COPY: {activeCard.color[model]()}
      </p>
    {/each}
  {/if}
</div>

<!-- <div ref:submenu class="submenu">
  {#each modelsEntries as key_value}
  <p class="menuitem">
    <label>
      <input type="checkbox" checked="{key_value[1]}" on:click="viewModelChenge(key_value)">
      {key_value[0].toUpperCase()}
    </label>
  </p>
  {/each}
</div> -->

<script>
  import store from '../store/store.js'
  import {styler, copyTextToClipboard} from '../utils'

  export default {
    data () {
      return {
        mode: false,
        activeCard: null,
        copys: ['hex', 'rgb', 'hsl'],
        sizes: [120, 240, 360],
      }
    },
    computed: {
      modelsEntries: ({ $cardViewModels }) => Object.entries($cardViewModels),
    },
    oncreate () {
      console.log('menu-render')
      const {menu, submenu} = this.refs
      const {mode} = this.get()

      const menuHide = (e) => {
        if (mode) {
          store.fire('menu_close')
        }
      }

      store.on('menu_open', (e, cardComponent, mode) => {
        menu.style.display = 'block'
        let x = e.clientX
        let y = e.clientY
        const rect = menu.getBoundingClientRect()
        if (window.innerWidth < rect.width + x) {
          x -= rect.width
        }
        if (window.innerHeight < rect.height + y) {
          y -= rect.height
        }
        styler(menu, {
          left: x,
          top: y,
        })

        // 'tip' or 'card'
        const activeCard = mode === 'card' ? cardComponent.get().card : cardComponent
        this.set({mode, activeCard})
        this.cardComponent = cardComponent


        window.addEventListener('blur', menuHide)
        document.addEventListener('click', menuHide)
      })

      store.on('menu_close', (e) => {
        menu.style.display = 'none'
        // submenu.style.display = 'none'
        this.set({mode: false})
        window.removeEventListener('blur', menuHide)
        document.removeEventListener('click', menuHide)
      })
    },
    methods: {
      // submenuVisible (el) {
      //   const {submenu} = this.refs
      //   submenu.style.display = 'block'
      //   const rect = el.getBoundingClientRect()
      //   styler(submenu, {
      //     left: rect.left + rect.width,
      //     top: rect.top,
      //   })
      // },
      add () {
        store.fire('cards.ADD_CARD', this.get().activeCard)
      },
      edit () {
        this.cardComponent.set({
          edit: true,
        })
        const title = this.cardComponent.refs.title
        const selection = window.getSelection()
        const range = document.createRange()
        const name = title.textContent
        // range.setStart(title, 0)
        // range.setEnd(title, title.childNodes.length)
        range.selectNodeContents(title)
        selection.removeAllRanges()
        selection.addRange(range)

        const editOff = (e, cb) => {
          if (title.textContent && title.textContent !== name) {
            store.fire('cards.EDIT_CARD', this.cardComponent.get().index, {
              name: title.textContent,
            })
            store.memo()
          } else {
            title.textContent = name
          }
          this.cardComponent.set({
            edit: false,
          })

          // 選択解除
          range.setStart(title, 0)
          range.setEnd(title, 0)
          selection.addRange(range)

          document.removeEventListener('selectionchange', cb)
          document.removeEventListener('click', cb)
          window.removeEventListener('blur', editOff)
        }
        const selectionchange = (e) => {
          const selection = window.getSelection()
          if (selection.focusNode.parentNode === title || selection.focusNode === title) {
            return
          }
          editOff(e, selectionchange)
        }
        const click = (e) => {
          if (e.target === title || e.target.classList.contains('menuitem')) {
            return
          }
          editOff(e, click)
        }
        document.addEventListener('selectionchange', selectionchange)
        document.addEventListener('click', click)
        window.addEventListener('blur', editOff)
      },
      duplicate () {
        const selects = this.root.selectable.selects
        // const howmany = selects.length
        if (selects.length) {
          store.fire('cards.DUPLICATE_CARD', selects.map((select) => select.index))
        }
        // // reselect
        // const {cards} = store.get()
        // this.root.selectable.reset()
        // for (let i = cards.length - 1; i >= cards.length - howmany; i--) {
        //   this.root.selectable.select(i)
        // }
      },
      remove () {
        const selects = this.root.selectable.selects
        if (selects.length) {
          store.fire('cards.REMOVE_CARD', selects.map((select) => select.index))
        }
      },
      reverse () {
        const selects = this.root.selectable.selects
        if (selects.length) {
          store.fire('cards.TOGGLE_TEXTMODE', selects.map((select) => select.index))
        }
      },

      copyColor (model) {
        copyTextToClipboard(this.get().activeCard.color[model]())
      },
      viewModelChenge (event) {
        const {cardViewModels} = this.store.get()
        cardViewModels[event[0]] = !event[1]
        this.store.set({cardViewModels}, true)
      },
    }
  }
</script>

<style>
  #menu, .submenu {
    position: absolute;
    font-size:12px;
    background: #fff;
    border: solid 1px silver;
    z-index: 100;
  }
  .menuitem {
    min-width: 100px;
    padding: 4px;
    margin: 0;
  }
  .menuitem:hover, .menuitem:active {
    background: aquamarine;
  }
</style>
